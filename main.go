package main

import (
	"flag"
	"fmt"
	"github.com/jarium/protoc-gen-http/gen"
	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
)

const (
	pluginName = "github.com/jarium/protoc-gen-http"
	version    = "1.0"
)

var (
	lib     *string
	libGens = map[string]gen.HttpLibGen{
		"net": gen.Net{},
		"gin": gen.Gin{},
	}
	selectedLibGen gen.HttpLibGen
)

func main() {
	var flags flag.FlagSet
	lib = flags.String("lib", "net", "http lib that will be used for generated code")

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(plugin *protogen.Plugin) error {
		g, ok := libGens[*lib]

		if !ok {
			var libNames string
			for n := range libGens {
				libNames += n + ","
			}

			libNames = libNames[:len(libNames)-1]
			return fmt.Errorf("invalid lib name provided, valid lib names: %s", libNames)
		}

		selectedLibGen = g

		for _, file := range plugin.Files {
			if !file.Generate {
				continue
			}
			generateFile(plugin, file)
		}
		return nil
	})
}

func generateFile(plugin *protogen.Plugin, file *protogen.File) {
	services := getHttpServices(file.Services)

	if len(services) == 0 {
		return //no service has http option
	}

	filename := file.GeneratedFilenamePrefix + "_http.pb.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-http. DO NOT EDIT.")
	g.P(fmt.Sprintf("// %s", pluginName))
	g.P(fmt.Sprintf("// version:%s", version))
	g.P()

	// Package declaration
	g.P("package ", file.GoPackageName)
	g.P()

	// Import necessary packages
	g.P("import (")
	g.P(`"context"`)
	g.P(`"errors"`)

	selectedLibGen.Imports(g)

	g.P(`"net/http"`)
	g.P(`"github.com/jarium/protoc-gen-http/pkg/apierror"`)
	g.P(")")

	for _, s := range services {
		genService(g, s)
	}
}

func genService(g *protogen.GeneratedFile, hs gen.HttpService) {
	g.P("// ", hs.S.GoName, "HTTPServer is the HTTP server interface.")
	g.P("type ", hs.S.GoName, "HTTPServer interface {")
	for _, method := range hs.Methods {
		g.P(method.M.GoName, "(context.Context, *", method.M.Input.GoIdent, ") (*", method.M.Output.GoIdent, ", error)")
	}
	g.P("}")
	g.P()

	selectedLibGen.ServerRegisterFunc(g, hs)

	g.P()

	for _, method := range hs.Methods {
		selectedLibGen.HandlerFunc(g, hs.S, method.M)
	}
}

// getHttpServices returns the http services with their methods that has http options
func getHttpServices(ps []*protogen.Service) []gen.HttpService {
	var services []gen.HttpService

	for _, service := range ps {
		hs := gen.HttpService{
			S: service,
		}
		for _, method := range service.Methods {
			if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
				continue
			}

			rule, ok := proto.GetExtension(method.Desc.Options(), annotations.E_Http).(*annotations.HttpRule)
			if rule != nil && ok {
				hs.Methods = append(hs.Methods, gen.HttpMethod{
					M:    method,
					Rule: rule,
				})
			}
		}

		if len(hs.Methods) > 0 {
			services = append(services, hs)
		}
	}

	return services
}
